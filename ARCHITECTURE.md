# 시스템 아키텍처 문서

## 목차
- [개요](#개요)
- [시스템 설계](#시스템-설계)
- [CVNet 프로토콜 명세](#cvnet-프로토콜-명세)
- [데이터 흐름 아키텍처](#데이터-흐름-아키텍처)
- [상태 관리](#상태-관리)
- [명령 큐 시스템](#명령-큐-시스템)
- [통신 계층](#통신-계층)
- [에러 처리 및 안정성](#에러-처리-및-안정성)
- [성능 최적화](#성능-최적화)

---

## 개요

야구호수공원 월패드 컨트롤러는 독점 CVNet RS485 프로토콜과 MQTT 간의 프로토콜 게이트웨이로, 한국 아파트 빌딩 자동화 시스템의 Home Assistant 통합을 가능하게 합니다.

### 설계 원칙

1. **프로토콜 독립적 MQTT 계층**: 쉬운 프로토콜 교체를 위한 추상화된 MQTT 통신
2. **상태 일관성**: 중복 방지 기능이 있는 단일 정보원(Single Source of Truth)
3. **안정적인 명령 전달**: ACK 검증이 포함된 큐 기반 시스템
4. **확장 가능한 아키텍처**: 설정 배열을 통한 모듈식 디바이스 지원
5. **장애 허용**: 우아한 성능 저하 및 자동 복구

---

## 시스템 설계

### 하이레벨 아키텍처

```
┌───────────────────────────────────────────────────────────────────┐
│                      Home Assistant 생태계                         │
│                                                                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐   │
│  │   프론트엔드  │  │  자동화      │  │  설정 YAML           │   │
│  │   (Lovelace) │  │   (Scripts)  │  │  (MQTT Entities)     │   │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────────────┘   │
│         │                 │                  │                    │
│         └─────────────────┴──────────────────┘                    │
│                           │                                       │
│                           │ MQTT 프로토콜                          │
│  ┌────────────────────────▼───────────────────────────────────┐  │
│  │              Mosquitto MQTT 브로커                         │  │
│  │  토픽: homenet/{device}{id}/{property}/[state|command]    │  │
│  │  QoS: 1 (최소 한 번 전달)                                 │  │
│  └────────────────────────┬───────────────────────────────────┘  │
└─────────────────────────────┼──────────────────────────────────────┘
                              │
                              │ TCP/IP (Port 1883)
                              │
┌─────────────────────────────▼──────────────────────────────────────┐
│                 월패드 컨트롤러 애드온 (Docker)                     │
│  ┌──────────────────────────────────────────────────────────────┐ │
│  │                    애플리케이션 계층                          │ │
│  │  ┌────────────┐  ┌────────────┐  ┌─────────────────────┐   │ │
│  │  │MQTT 클라이언트│  │상태 관리자 │  │ 명령 큐             │   │ │
│  │  │(Pub/Sub)   │  │(homeStatus)│  │ (배열 + 타이머)     │   │ │
│  │  └─────┬──────┘  └─────┬──────┘  └──────┬──────────────┘   │ │
│  │        │                │                │                   │ │
│  │        └────────────────┴────────────────┘                   │ │
│  │                         │                                    │ │
│  │  ┌──────────────────────▼──────────────────────────────┐    │ │
│  │  │         프로토콜 변환 계층                           │    │ │
│  │  │  • CVNet 패킷 파서 (15바이트 구조)                 │    │ │
│  │  │  • 명령 빌더 (체크섬 계산)                          │    │ │
│  │  │  • 디바이스 상태 매퍼 (DEVICE_STATE 배열)          │    │ │
│  │  │  • 명령 템플릿 엔진 (DEVICE_COMMAND 배열)          │    │ │
│  │  └──────────────────────┬──────────────────────────────┘    │ │
│  └─────────────────────────┼───────────────────────────────────┘ │
│                            │                                      │
│  ┌─────────────────────────▼───────────────────────────────────┐ │
│  │              전송 계층 추상화                                │ │
│  │  ┌──────────────────┐          ┌──────────────────────┐    │ │
│  │  │ 시리얼 전송      │    또는   │  소켓 전송           │    │ │
│  │  │ (SerialPort)    │          │  (net.Socket)        │    │ │
│  │  │ /dev/ttyUSB0     │          │  TCP: 192.168.x.x    │    │ │
│  │  └────────┬─────────┘          └──────────┬───────────┘    │ │
│  └───────────┼────────────────────────────────┼────────────────┘ │
└──────────────┼────────────────────────────────┼──────────────────┘
               │                                │
               │ RS485 전기신호                 │ WiFi/Ethernet
               │ (물리 계층)                    │ (EW11 브릿지)
               │                                │
┌──────────────▼────────────────────────────────▼──────────────────┐
│                    월패드 컨트롤러 하드웨어                        │
│              (CVNet 프로토콜 - 독점 시스템)                       │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────────────┐   │
│  │ 조명     │ │ 온도조절  │ │   팬     │ │ 가스/문/센서     │   │
│  │ 모듈     │ │  모듈    │ │  모듈    │ │    모듈          │   │
│  └──────────┘ └──────────┘ └──────────┘ └──────────────────┘   │
└───────────────────────────────────────────────────────────────────┘
```

### 컴포넌트 책임

| 컴포넌트 | 파일 | 책임 |
|----------|------|------|
| **프로토콜 파서** | cvnet_socket.js:191-350 | 수신된 15바이트 CVNet 패킷 파싱, 디바이스 타입 식별 |
| **상태 관리자** | cvnet_socket.js:167 | `homeStatus` 객체 유지, 중복 업데이트 방지 |
| **MQTT 클라이언트** | cvnet_socket.js:174-179 | 상태 변경 발행, 명령 토픽 구독 |
| **명령 큐** | cvnet_socket.js:170 | ACK 검증, 지연 관리가 포함된 FIFO 큐 |
| **디바이스 매퍼** | cvnet_socket.js:39-71 | 상태 패킷 인식 패턴 정의 |
| **명령 빌더** | cvnet_socket.js:73-150 | 체크섬이 포함된 사전 정의 제어 명령 |
| **전송 계층** | cvnet_socket.js:182-188 | 구분자 파싱이 있는 소켓 또는 시리얼 연결 |
| **시작 관리자** | run.sh | 설정 로드, 구현 파일 선택, Node.js 시작 |

---

## CVNet 프로토콜 명세

### 패킷 구조

#### 표준 명령/상태 패킷 (15바이트)

```
┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐
│ 0xF7 │ 0x20 │ CMD  │ 0x01 │ ZONE │ DATA │ 0x00 │ 0x00 │ 0x00 │ 0x00 │ 0x00 │ 0x00 │ 0x00 │ CSUM │ 0xAA │
├──────┼──────┼──────┼──────┼──────┼──────┼──────┼──────┼──────┼──────┼──────┼──────┼──────┼──────┼──────┤
│  0   │  1   │  2   │  3   │  4   │  5   │  6   │  7   │  8   │  9   │  10  │  11  │  12  │  13  │  14  │
└──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘

시작      헤더       명령       존/ID        데이터      패딩 (7바이트)          체크섬    끝
```

**바이트 정의:**
- **바이트 0**: `0xF7` - 시작 마커 (고정)
- **바이트 1**: `0x20` - 헤더/소스 식별자
- **바이트 2**: 디바이스 명령 타입
  - `0x21`: 거실등
  - `0x22`: 게임방등
  - `0x23`: 침실등
  - `0x24`: 아이방등
  - `0x41-0x44`: 온도조절기 존 1-4
  - `0x4A`: 온도조절기 상태 쿼리
- **바이트 3**: `0x01` - 고정 프로토콜 버전
- **바이트 4**: 서브 존 식별자
  - `0x11`: 존 1
  - `0x12`: 존 2
  - `0x13`: 존 3
  - `0x81`: 상태 쿼리 응답
- **바이트 5**: 데이터 페이로드
  - 조명: `0x00` (OFF) 또는 `0x01-0x0A` (밝기 레벨)
  - 온도조절기: 온도 = `(바이트 - 128)` 섭씨
- **바이트 6-12**: 패딩 (보통 `0x00`)
- **바이트 13**: 체크섬 - 바이트 1-12의 합, 마지막 2자리 16진수 사용
- **바이트 14**: `0xAA` - 종료 마커 (패킷 구분자)

#### 압축 패킷 (8바이트) - 팬/가스

```
┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐
│시작  │ CMD  │ SUB  │ DATA │ 0x00 │ 0x00 │ 0x00 │ CSUM │
├──────┼──────┼──────┼──────┼──────┼──────┼──────┼──────┤
│  0   │  1   │  2   │  3   │  4   │  5   │  6   │  7   │
└──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘
```

**팬 명령:**
- `0x78 01 01 00 00 00 00 7A`: 전원 OFF
- `0x78 01 02 01 00 00 00 7C`: 약풍
- `0x78 01 02 02 00 00 00 7D`: 중풍
- `0x78 01 02 03 00 00 00 7E`: 강풍

**가스 명령:**
- `0x11 01 80 00 00 00 00 92`: 밸브 닫기 (긴급)

### 프로토콜 예제

#### 예제 1: 거실 조명 밝기 레벨 5

**명령 패킷:**
```
F7 20 21 01 11 05 00 00 00 00 00 00 00 58 AA
│  │  │  │  │  │                       │  │
│  │  │  │  │  │                       │  └─ 종료 구분자
│  │  │  │  │  │                       └─ 체크섬 (0x58)
│  │  │  │  │  └─ 밝기 = 5
│  │  │  │  └─ 존 1
│  │  │  └─ 프로토콜 버전
│  │  └─ 거실 (0x21)
│  └─ 헤더
└─ 시작 마커
```

**체크섬 계산:**
```javascript
sum = 0x20 + 0x21 + 0x01 + 0x11 + 0x05 + 0x00*7 = 0x58
```

**ACK 응답:**
```
20 01 21 9F
│  │  │  └─ ACK 플래그
│  │  └─ 명령 확인 (0x21)
│  └─ 프로토콜 버전
└─ 헤더
```

#### 예제 2: 온도조절기 목표 온도 22°C 설정

**명령 패킷:**
```
F7 20 41 01 11 96 00 00 00 00 00 00 00 09 AA
                  │                       │
                  │                       └─ 체크섬 (0x09)
                  └─ 온도 = 0x96 (150 DEC)
                      → (150 - 128) = 22°C
```

**온도 인코딩 공식:**
```javascript
// 인코딩: 목표 온도를 HEX로
hexValue = (temperature + 128).toString(16)
// 22°C → (22 + 128) = 150 DEC = 0x96 HEX

// 디코딩: HEX를 섭씨로
temperature = parseInt(hexValue, 16) - 128
// 0x96 → 150 DEC → (150 - 128) = 22°C
```

#### 예제 3: 온도조절기 상태 응답

**상태 패킷:**
```
F7 20 01 4A 81 00 96 00 94 00 00 00 00 ... AA
         │  │     │     │
         │  │     │     └─ 존 2 현재 온도 (0x94 = 20°C)
         │  │     └─ 존 1 설정 온도 (0x96 = 22°C)
         │  └─ 상태 응답 플래그
         └─ 온도조절기 상태 쿼리
```

**파싱 로직:**
```javascript
// cvnet_socket.js:50
{
  deviceId: 'Thermo',
  subId: ['1','2','3','4'],
  stateStartWithHex: 'F7 20 01 4A 81',
  whereToReadBlock: [6, 8, 10, 12],  // 바이트 위치
  setTemp: '',
  curTemp: '',
  power: ''
}

// 존 1: 바이트 6 (설정) + 바이트 7 (현재)
// 존 2: 바이트 8 (설정) + 바이트 9 (현재)
// ...
```

---

## 데이터 흐름 아키텍처

### 상태 업데이트 흐름 (월패드 → Home Assistant)

```
┌────────────────┐
│ 사용자가 월패드 │
│ 버튼 누름      │
└────────┬───────┘
         │
         ▼
┌────────────────────────────────┐
│ 월패드가 상태 브로드캐스트      │
│ F7 20 01 21 81 01 ... AA       │
└────────┬───────────────────────┘
         │
         │ RS485 버스
         ▼
┌────────────────────────────────┐
│ 파서가 패킷 수신               │
│ (구분자: 0xAA)                 │
└────────┬───────────────────────┘
         │
         ▼
┌────────────────────────────────┐
│ DEVICE_STATE 배열에서          │
│ 일치하는 패턴 찾기              │
│ obj.stateStartWithHex == data  │
└────────┬───────────────────────┘
         │
         ▼
┌────────────────────────────────┐
│ 디바이스 속성 추출              │
│ deviceId, subId, values        │
└────────┬───────────────────────┘
         │
         ▼
┌────────────────────────────────┐
│ homeStatus에서 변경사항 확인   │
│ if (value !== homeStatus[...]) │
└────────┬───────────────────────┘
         │ 상태 변경됨
         ▼
┌────────────────────────────────┐
│ homeStatus 객체 업데이트       │
│ homeStatus[dev][sub][prop]     │
└────────┬───────────────────────┘
         │
         ▼
┌────────────────────────────────┐
│ MQTT에 발행                    │
│ homenet/Light1/power/state=ON  │
└────────┬───────────────────────┘
         │
         ▼
┌────────────────────────────────┐
│ Home Assistant가 업데이트 수신 │
│ UI에 새 상태 반영              │
└────────────────────────────────┘
```

### 명령 흐름 (Home Assistant → 월패드)

```
┌────────────────┐
│ 사용자가 HA에서│
│ 조명 스위치 클릭│
└────────┬───────┘
         │
         ▼
┌─────────────────────────────────┐
│ HA가 MQTT 명령 발행             │
│ homenet/Light1/power/command=ON │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ MQTT 클라이언트가 메시지 수신   │
│ client.on('message', ...)       │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ 토픽 및 페이로드 파싱           │
│ 추출: device, subId, prop       │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ DEVICE_COMMAND에서 명령 찾기    │
│ 일치: deviceId, subId, value    │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ 패킷 빌드 (동적인 경우)         │
│ 예: 온도 체크섬 계산            │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ 명령을 queue[]에 추가           │
│ queue.push({cmd, ack, topic})   │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ sendDelay 대기 (150ms)          │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ 월패드로 패킷 전송              │
│ sock.write(commandHex)          │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ ACK 응답 대기                   │
│ ackHex 일치 확인                │
└────────┬────────────────────────┘
         │ ACK 수신됨
         ▼
┌─────────────────────────────────┐
│ 큐에서 제거, 다음 처리          │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ 월패드가 디바이스 상태 업데이트 │
│ 조명이 물리적으로 켜짐          │
└─────────────────────────────────┘
```

---

## 상태 관리

### homeStatus 객체 구조

```javascript
homeStatus = {
  Light: {
    '1': {power: 'ON', brightness: '5'},
    '2': {power: 'OFF'},
    '3': {power: 'ON'},
    '4': {power: 'OFF'},
    '5': {power: 'ON'},
    '6': {power: 'OFF'},
    '7': {power: 'ON'}
  },
  Thermo: {
    '1': {power: 'heat', setTemp: '22', curTemp: '20'},
    '2': {power: 'off', setTemp: '0', curTemp: '18'},
    '3': {power: 'heat', setTemp: '23', curTemp: '21'},
    '4': {power: 'heat', setTemp: '20', curTemp: '19'}
  },
  Fan: {
    '1': {power: 'ON', speed: 'medium'}
  },
  Gas: {
    '1': {power: 'ON'}
  },
  Door: {
    '1': {open: 'Off'},
    '2': {open: 'Off'}
  }
}
```

### 중복 방지 로직

```javascript
// cvnet_socket.js:240-280 (단순화)
function updateState(deviceId, subId, property, value) {
  // 필요시 중첩 구조 초기화
  if (!homeStatus[deviceId]) homeStatus[deviceId] = {};
  if (!homeStatus[deviceId][subId]) homeStatus[deviceId][subId] = {};

  // 값이 실제로 변경되었는지 확인
  if (homeStatus[deviceId][subId][property] !== value) {
    // 내부 상태 업데이트
    homeStatus[deviceId][subId][property] = value;

    // 변경된 경우에만 MQTT에 발행
    const topic = util.format(CONST.STATE_TOPIC, deviceId, subId, property);
    client.publish(topic, value, {qos: 1, retain: true});

    log('상태 업데이트:', deviceId + subId, property, '=', value);
  }
}
```

### 상태 동기화 지연

```javascript
// MQTT 명령 에코 루프 방지
const mqttDelay = CONFIG.mqtt.receiveDelay; // 기본값: 10000ms

// 명령 전송 후, 10초 동안 상태 업데이트 무시
// 월패드가 명령을 에코백할 때 자체 트리거 방지
```

---

## 명령 큐 시스템

### 큐 구조

```javascript
queue = [
  {
    commandHex: Buffer,    // 전송할 패킷
    ackHex: Buffer,        // 예상 응답
    topic: String,         // 로깅용 MQTT 토픽
    timestamp: Number      // 큐 추가 시간
  },
  // ... 추가 명령
]
```

### 큐 처리 알고리즘

```javascript
// cvnet_socket.js:400-450에서 단순화

setInterval(() => {
  if (queue.length === 0) return;

  const cmd = queue[0];  // FIFO: 첫 번째 명령 가져오기

  // 월패드로 명령 전송
  sock.write(cmd.commandHex);
  log('명령 전송:', cmd.commandHex.toString('hex'));

  // ACK 검증 타임아웃 설정
  setTimeout(() => {
    // ACK 수신시, 파서가 큐에서 제거
    // 타임아웃시, 재전송 또는 에러 로깅
    if (queue[0] === cmd) {
      log('경고: ACK 미수신, 재시도 중...');
      // 여기서 재시도 로직 구현 가능
    }
  }, 1000);  // ACK 대기 1초

}, CONST.sendDelay);  // 150ms마다 큐 처리
```

### ACK 검증

```javascript
// 월패드로부터 패킷 수신 시
parser.on('data', (data) => {
  // 대기 중인 명령에 대한 ACK인지 확인
  if (queue.length > 0) {
    const pending = queue[0];

    // 데이터에 예상 ACK가 포함되어 있는지 확인
    if (data.includes(pending.ackHex)) {
      log('ACK 수신:', pending.topic);
      queue.shift();  // 큐에서 제거
      return;  // 상태 업데이트로 처리하지 않음
    }
  }

  // ACK가 아니면, 상태 업데이트로 처리
  // ... 상태 파싱 로직
});
```

---

## 통신 계층

### 계층 1: 물리 전송

#### 시리얼 모드 (USB-to-RS485)
```javascript
// serialport 라이브러리
const SerialPort = require('serialport');
const port = new SerialPort(CONFIG.serial.port, {
  baudRate: CONFIG.serial.baudrate,  // 9600
  dataBits: 8,
  stopBits: 1,
  parity: CONFIG.serial.parity       // 'none', 'even', 'odd'
});
```

#### 소켓 모드 (WiFi/이더넷 브릿지)
```javascript
// net 라이브러리 (TCP 소켓)
const net = require('net');
const sock = new net.Socket();
sock.connect(CONFIG.socket.port, CONFIG.socket.deviceIP);
// EW11 또는 유사한 RS485-to-WiFi 브릿지에 연결
```

### 계층 2: 패킷 구분

```javascript
const Delimiter = require('@serialport/parser-delimiter');
const parser = sock.pipe(new Delimiter({
  delimiter: [0xAA]  // 0xAA 바이트로 스트림 분할
}));

// 완전한 패킷 처리 보장
// 부분 읽기 및 버퍼링 자동 처리
```

### 계층 3: MQTT 통신

```javascript
// mqtt 라이브러리 v4.2.8
const client = mqtt.connect(CONST.mqttBroker, {
  clientId: CONST.clientID,
  username: CONST.mqttUser,
  password: CONST.mqttPass,
  qos: 1,          // 최소 한 번 전달
  retain: true     // 브로커에 마지막 상태 유지
});
```

**토픽 구조:**
```
homenet/
├── Light1/
│   ├── power/
│   │   ├── state     (애드온이 발행)
│   │   └── command   (애드온이 구독)
│   └── brightness/
│       ├── state
│       └── command
├── Thermo1/
│   ├── power/state|command
│   ├── setTemp/state|command
│   └── curTemp/state
└── ...
```

---

## 에러 처리 및 안정성

### 연결 재시도 로직

```javascript
// 연결 끊김 시 자동 재연결
sock.on('close', () => {
  log('소켓 연결 끊김, 5초 후 재연결...');
  setTimeout(() => {
    sock.connect(CONFIG.socket.port, CONFIG.socket.deviceIP);
  }, 5000);
});

// MQTT 자동 재연결 (내장)
client.on('offline', () => {
  log('MQTT 오프라인, 자동 재연결 중...');
});
```

### 패킷 검증

```javascript
function validatePacket(data) {
  // 최소 길이 확인
  if (data.length < 8) return false;

  // 시작 마커 확인 (15바이트 패킷용)
  if (data[0] !== 0xF7) return false;

  // 체크섬 확인
  const calculatedSum = data.slice(1, 13).reduce((a, b) => a + b, 0);
  const expectedSum = data[13];
  if ((calculatedSum & 0xFF) !== expectedSum) {
    log('체크섬 불일치!');
    return false;
  }

  return true;
}
```

### 상태 복구

```javascript
// MQTT retain 플래그로 마지막 알려진 상태 유지
client.publish(topic, value, {
  qos: 1,      // 전달 보장
  retain: true // 브로커가 마지막 값 저장
});

// 재연결 시, Home Assistant가 유지된 상태 수신
// 수동 상태 동기화 불필요
```

---

## 성능 최적화

### 구현된 기법

1. **패킷 버퍼링**: 구분자 파서가 불완전한 읽기 처리
2. **상태 캐싱**: `homeStatus`가 중복 MQTT 발행 방지
3. **큐 쓰로틀링**: 명령 간 150ms 지연으로 버스 포화 방지
4. **선택적 로깅**: 설정 가능한 디버그 모드로 I/O 오버헤드 감소
5. **이벤트 기반 아키텍처**: 논블로킹 비동기 작업

### 성능 메트릭

| 항목 | 수치 | 비고 |
|------|------|------|
| 명령 지연 시간 | <150ms | 큐 지연 + 전송 시간 |
| 상태 업데이트 지연 | <50ms | 월패드 → MQTT 발행 시간 |
| 메모리 사용량 | ~30MB | Node.js + 라이브러리 |
| CPU 사용률 | <5% | 라즈베리파이 4 유휴 상태 |
| 네트워크 대역폭 | <1KB/s | 평균 MQTT 트래픽 |
| 최대 큐 깊이 | 무제한 | 월패드 무응답 시 증가 |

### 확장성 고려사항

- **다중 월패드 지원**: 다른 설정으로 여러 인스턴스 실행 가능
- **디바이스 제한**: MQTT 토픽 제한은 이론적 최대값 (~10K 토픽)
- **동시 명령**: 큐가 직렬화된 전달 보장 (RS485 제한사항)

---

## 설정 스키마

### 완전한 설정 예제

```json
{
  "model": "commax",
  "type": "socket",
  "sendDelay": 150,
  "serial": {
    "port": "/dev/ttyUSB0",
    "baudrate": 9600,
    "parity": "none"
  },
  "socket": {
    "deviceIP": "192.168.1.100",
    "port": 8899
  },
  "mqtt": {
    "server": "192.168.1.50",
    "username": "homeassistant",
    "password": "secure_password",
    "receiveDelay": 10000
  },
  "customfile": "my_custom_wallpad.js"
}
```

### 파라미터 설명

| 파라미터 | 타입 | 기본값 | 설명 |
|----------|------|--------|------|
| `model` | 문자열 | "commax" | 월패드 제조사 (commax/samsung/daelim/hyundai) |
| `type` | 문자열 | "serial" | 연결 타입 (serial/socket) |
| `sendDelay` | 정수 | 150 | 큐 명령 간 밀리초 |
| `serial.port` | 문자열 | "/dev/ttyUSB0" | 시리얼 디바이스 경로 |
| `serial.baudrate` | 정수 | 9600 | RS485 전송 속도 |
| `serial.parity` | 문자열 | "none" | 패리티 비트 (none/even/odd) |
| `socket.deviceIP` | 문자열 | - | RS485-to-WiFi 브릿지 IP 주소 |
| `socket.port` | 정수 | 8899 | 브릿지 디바이스 TCP 포트 |
| `mqtt.server` | 문자열 | - | MQTT 브로커 IP 주소 |
| `mqtt.username` | 문자열 | - | MQTT 인증 사용자명 |
| `mqtt.password` | 문자열 | - | MQTT 인증 비밀번호 |
| `mqtt.receiveDelay` | 정수 | 10000 | 전송 후 N ms 동안 MQTT 명령 무시 |
| `customfile` | 문자열 | null | /share의 커스텀 JS 구현 |

---

## 개발 및 디버깅

### 패킷 분석 도구

```bash
# 패킷 스니퍼 실행
node test.js /dev/ttyUSB0 9600 none

# 출력 예제:
[2024-01-15 14:30:22] 새 패킷: F7 20 01 21 81 01 05 00 00...
[2024-01-15 14:30:22] 타입: 조명
[2024-01-15 14:30:22] 거실등 ON, 밝기 5
```

### 새 디바이스 지원 추가

1. **패킷 캡처** - test.js 사용
2. **패턴 식별** - DEVICE_STATE 배열에서
3. **명령 정의** - DEVICE_COMMAND 배열에서
4. **체크섬 계산** - 명령 패킷용
5. **테스트** - Home Assistant MQTT로

### 커스텀 구현

`/share/my_wallpad.js` 생성:

```javascript
const mqtt = require('mqtt');
const SerialPort = require('serialport');

// 커스텀 프로토콜 구현
// 기존 파일과 동일한 인터페이스 내보내기 필요
```

---

## 보안 고려사항

1. **MQTT 인증**: 항상 사용자명/비밀번호 사용
2. **네트워크 분리**: 월패드 네트워크를 WAN에서 격리
3. **펌웨어 업데이트**: Home Assistant와 애드온을 최신 상태로 유지
4. **접근 제어**: Home Assistant 사용자 인증 사용
5. **패킷 주입 위험**: RS485 버스는 암호화되지 않음 (물리 보안 필요)

---

## 향후 개선사항

### 계획된 기능
- [ ] 추가 패킷 분석을 통한 엘리베이터 호출 통합
- [ ] 에너지 모니터링 (월패드 지원 시)
- [ ] JSON 편집 대신 웹 UI 설정
- [ ] 커스텀 명령용 자동 체크섬 계산
- [ ] 다국어 지원 (한국어/영어)
- [ ] Home Assistant MQTT 자동 검색 지원

### 연구 영역
- 향상된 보안을 위한 프로토콜 암호화 계층
- 미지 패킷 분류를 위한 머신러닝
- 양방향 상태 검증 (읽기 확인)
- 최신 CVNet 프로토콜 버전 지원

---

## 참고 자료

- **CVNet 프로토콜**: 패킷 분석을 통한 리버스 엔지니어링
- **Home Assistant MQTT**: https://www.home-assistant.io/integrations/mqtt/
- **RS485 표준**: TIA-485-A 전기 규격
- **Node.js SerialPort**: https://serialport.io/docs/
- **MQTT 사양**: OASIS MQTT Version 3.1.1

---

**문서 버전**: 1.0
**최종 업데이트**: 2024년 7월 15일
**관리**: YOSKR (강대환님의 원본 작업 기반)
